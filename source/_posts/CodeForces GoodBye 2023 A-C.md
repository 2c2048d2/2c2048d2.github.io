---
title: CodeForces GoodBye 2023 A-C
---
# 测试标题

---
## C
### 题目分析
使结果最大化的人的先下
很明显只有三种选法 一奇一偶 两个偶数 两个奇数
下面是两个人的优先策略 前者***不满足***才会选择后者
不满足就是没那么多数让你选
最大化： 两个奇数（因为对方需要奇数才能让结果-1） | 两个偶数 | 一奇一偶
最小化： 一奇一偶（只有这个才能让结果变少 | 两个奇数 | 两个偶数
### 朴素算法：
我们维护奇数偶数的数量，再判断下哪种就行
### 优化：
朴素TLE了 （悲
那我们考虑一下怎么优化
可以发现只有第一次下可能不存在偶数，而我们先下的人他是先考虑消耗两个奇数的下法（就是说他不考虑偶数
那么我们后下的这位肯定是能满足有偶数的条件的
等于说，这两位下棋都不需要考虑偶数
那我们就来看奇数

假设奇数是足够的
那么前手会先消耗两个奇数
后手会消耗一个奇数
那一轮就是消耗3个奇数，使结果-1
最后如果剩下两个，那么先手会用掉这两个，结果不变
如果最后剩下一个，那谁用都会再使结果-1
所以就是看每次奇数的个数，
答案就是sum - n/3 - (n%3==1)

如果奇数不够呢
那很明显，需要特殊考虑的只有 只有一个奇数 的情况
从2个开始上述式子都可以正确处理

``` C++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
signed main() {
  cin.tie(0)->sync_with_stdio(false);
  int T = 1;
  cin >> T;
  while (T--) {
    int n;cin >> n;
    LL odd_num = 0, sum = 0;
    for (int now, i = 1;i <= n;i++) {
      cin >> now, sum += now;
      odd_num += now & 1;
      if (odd_num == 1 && i == 1) cout << sum << ' ';
      else cout << sum - odd_num / 3 - (odd_num % 3 == 1) << ' ';
    }
    puts("");
  }
}
```